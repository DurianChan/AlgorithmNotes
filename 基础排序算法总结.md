# 基础排序算法总结

| 排序名称 | 排序思想                                                     | 时间复杂度        |
| -------- | ------------------------------------------------------------ | ----------------- |
| 冒泡排序 | 通过两次循环，一个元素与每个元素逐次对比大小，交换位置进行排序 | O(n^2)            |
| 选择排序 | 一次循环将当前下标定义为最小值，二次循环发现有小于关键字的值，将该值赋值给关键字，二次循环结束后判读关键字的数组值若不等于原本下标的值，则交换下标值与关键字的元素位置 | O(n^2)            |
| 插入排序 | 从第一个元素开始，该元素可认为已被排序；  取出下一个元素，在已经排序的元素序列中从后向前扫描；  如果扫描的元素(已排序)大于新元素，该元素移到下一个位置；  重复步骤3，直到找到已排序的元素小于或等于新元素的位置  将新元素插入到该位置后  重复步骤2-5  设置一个已排好序元素，将后面元素按小大逐个扫描插入位置 | O(n^2)            |
| 希尔排序 | 希尔排序，也叫缩小增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能，这样可以让一个元素一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已经排好的(此时插入排序较快)。 | O(n^1.5) - O(n^2) |
| 堆排序   | 堆分为"最大堆"和"最小堆"。最大堆通常被用来进行"升序"排序，而最小堆通常被用来进行"降序"排序。       堆化：反向调整使得每个子树都是大顶堆或者小顶堆。    按序输出元素：把堆顶和最末的元素对调，然后调整堆顶元素(将大的元素调整为父节点的值)。      以从小到大排序为例，对整个数据记录序列初始建立“大顶堆”，然后根结点为最大关键字，和序列最后一个关键字记录交换，继续对剩下的前n-1个记录序列进行调整，重新变成新的“大顶堆”，如此反复，每次可以得到当前子序列最大的关键字，最后即可得到从小到大的序列。 | O(n*log(n))       |
| 归并排序 | 分解：将n个元素分解成各含n/2个元素的子序列；    解决：对两个子序列递归的排序；    合并：合并两个已排序的子序列得到排序结果。      归并排序是一种递归算法，持续地将一个数组分成两半。如果数组是空的或者只有一个元素，那么根据定义，它就被排序好了。如果数组里的元素超过一个，我们就把数组拆分，然后分别对两个部分调用递归排序，一旦这两个部分被排序好了，就对这两个部分进行归并。 | O(n*log(n)        |
| 快速排序 | 先在当前区间利用partition()找到一个基点，将小于这个基点的数放在基点左侧，大于基点的数放在基点右侧    然后再分别对这个基点左侧区间和右侧区间进行上述处理，递归下去即可完成排序 | O(n*log(n)        |